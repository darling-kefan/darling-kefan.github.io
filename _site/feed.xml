<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>tangmi的笔记本</title>
    <description>tangmi的笔记本</description>
    <link>http://www.tangmi.me/</link>
    <atom:link href="http://www.tangmi.me/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 01 Jan 2016 23:42:12 +0800</pubDate>
    <lastBuildDate>Fri, 01 Jan 2016 23:42:12 +0800</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    
      <item>
        <title>带环链表--LintCode</title>
        <description>&lt;p&gt;给定一个链表，判断它是否有环。
&lt;!--break--&gt;&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;示例&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;给出 -21-&amp;gt;10-&amp;gt;4-&amp;gt;5, tail connects to node index 1，返回 true
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-1&quot;&gt;算法思路&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;定义两个指针变量p和q，都指向head；
在循环中，p走两步，q走一步，如果存在环，则总会让这两个指针相遇，则结束循环并返回true；
如果p或p-&amp;gt;next最终指向NULL，说明没有环（没有相遇）
时间复杂度：
如果不存在环：则为O(n/2)
如果存在环：则为O(n)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-2&quot;&gt;代码实现&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * Definition of ListNode
 * class ListNode {
 * public:
 *     int val;
 *     ListNode *next;
 *     ListNode(int val) {
 *         this-&amp;gt;val = val;
 *         this-&amp;gt;next = NULL;
 *     }
 * }
 */
class Solution
{
public:
    /**
     * @param head: The first node of linked list.
     * @return: True if it has a cycle, or false
     */
    bool hasCycle(ListNode *head)
    {
        ListNode *p = head;
        ListNode *q = head;
        while(p != NULL &amp;amp;&amp;amp; p-&amp;gt;next != NULL)
        {
            p = p-&amp;gt;next-&amp;gt;next;
            q = q-&amp;gt;next;
            if(p == q)
            {
                return true;
            }
        }
        return false;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Wed, 08 Jul 2015 05:18:09 +0800</pubDate>
        <link>http://www.tangmi.me/blog/linked-list-cycle</link>
        <guid isPermaLink="true">http://www.tangmi.me/blog/linked-list-cycle</guid>
        
        <category>链表</category>
        
        
        <category>LintCode</category>
        
      </item>
    
      <item>
        <title>二进制中有多少个1--LintCode</title>
        <description>&lt;p&gt;计算在一个 32 位的整数的二进制表式中有多少个 1.
&lt;!--break--&gt;&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;示例&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;给定 32 (100000)，返回 1
给定 5 (101)，返回 2
给定 1023 (111111111)，返回 9
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-1&quot;&gt;算法思路&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1：将num和1进行按位与操作（计算最低位是不是1），将结果累加，并将num右移一位；
2：循环运行步骤1，直到num不大于0后，则结束，将累加结果返回；
时间复杂度O(log n)，有更快的实现方法欢迎讨论 ^_^
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-2&quot;&gt;代码实现&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Solution
{
public:
    /**
    * @param num: an integer
    * @return: an integer, the number of ones in num
    */
    int countOnes(int num)
    {
        int idx = 0;
        while(num &amp;gt; 0)
        {
            idx += num &amp;amp; 1;
            num = num &amp;gt;&amp;gt; 1;
        }
        return idx;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Tue, 07 Jul 2015 03:41:01 +0800</pubDate>
        <link>http://www.tangmi.me/blog/count-1-in-binary</link>
        <guid isPermaLink="true">http://www.tangmi.me/blog/count-1-in-binary</guid>
        
        <category>位运算</category>
        
        
        <category>LintCode</category>
        
      </item>
    
      <item>
        <title>在O(1)时间复杂度删除链表节点--LintCode</title>
        <description>&lt;p&gt;给定一个单链表中的表头和一个等待被删除的节点(非表头或表尾)。请在在O(1)时间复杂度删除该链表节点。
&lt;!--break--&gt;&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;示例&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;给定 1-&amp;gt;2-&amp;gt;3-&amp;gt;4，和节点 3，返回 1-&amp;gt;2-&amp;gt;4。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-1&quot;&gt;算法思路&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;一般做法是从表头开始遍历，时间复杂度是O(n)，但本题形参并没有给出表头指针且同时要求O(1)复杂度；
所以想到的做法是把”待删除节点的下一个节点值“ 复制到”待删除节点“，并指向“待删除节点的下一个节点的下一个节点“；
”进而释放”下一个节点“ 来达到O(1)的删除操作；
另外，注意题目中的”非表头或表尾“，如果是表尾节点，那么就不能这么做，因为释放了尾节点的话，上一个节点的next就变成悬浮指针了；
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-2&quot;&gt;代码实现&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
* Definition of ListNode
* class ListNode {
* public:
*     int val;
*     ListNode *next;
*     ListNode(int val) {
*         this-&amp;gt;val = val;
*         this-&amp;gt;next = NULL;
*     }
* }
*/
class Solution
{
public:
    /**
    * @param node: a node in the list should be deleted
    * @return: nothing
    */
    void deleteNode(ListNode *node)
    {
        if(node != NULL)
        {
            ListNode *tmp = node-&amp;gt;next; // 待删除的下一个节点
            node-&amp;gt;val = tmp-&amp;gt;val; // 待删除节点值等于&quot;下一个节点值&quot;
            node-&amp;gt;next = tmp-&amp;gt;next; // 待删除节点指向&quot;下一个节点的下一个节点&quot;
            free(tmp); // 释放 &quot;待删除节点的下一个节点&quot;
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Sun, 05 Jul 2015 21:44:19 +0800</pubDate>
        <link>http://www.tangmi.me/blog/delete-node-in-the-middle-of-singly-linked-list</link>
        <guid isPermaLink="true">http://www.tangmi.me/blog/delete-node-in-the-middle-of-singly-linked-list</guid>
        
        <category>链表</category>
        
        
        <category>LintCode</category>
        
      </item>
    
      <item>
        <title>O(1)检测2的幂次--LintCode</title>
        <description>&lt;p&gt;用 O(1) 时间检测整数 n 是否是 2 的幂次。&lt;/p&gt;

&lt;!--break--&gt;

&lt;h4 id=&quot;section&quot;&gt;示例&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;n=4，返回 true;
n=5，返回 false.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-1&quot;&gt;算法思路&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//TODO
时间复杂度：O(1) 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-2&quot;&gt;代码实现&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Solution
{
public:
    /*
    * @param n: An integer
    * @return: True or false
    */
    bool checkPowerOf2(int n)
    {
        if(n &amp;gt; 0 &amp;amp;&amp;amp; (n &amp;amp; n-1) == 0)
        {
            return true;
        }
        else
        {
            return false;
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Sun, 05 Jul 2015 08:38:20 +0800</pubDate>
        <link>http://www.tangmi.me/blog/o1-check-power-of-2</link>
        <guid isPermaLink="true">http://www.tangmi.me/blog/o1-check-power-of-2</guid>
        
        <category>位运算</category>
        
        
        <category>LintCode</category>
        
      </item>
    
      <item>
        <title>搜索二维矩阵--LintCode</title>
        <description>&lt;p&gt;写出一个高效的算法来搜索 m × n矩阵中的值。
这个矩阵具有以下特性：
每行中的整数从左到右是排序的,每行的第一个数大于上一行的最后一个整数。&lt;/p&gt;

&lt;!--break--&gt;

&lt;h4 id=&quot;section&quot;&gt;示例&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;考虑如下矩阵:
[
  [1, 3, 5, 7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
给出 target = 3，返回 true
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-1&quot;&gt;算法思路&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. 首先对所有行末元素通过二分查找找到小于等于target的行下标；
2. 再对该行所有元素通过二分查找，如果找到等于target的元素则返回true，否则返回false。
时间复杂度：O(log(n) + log(m)) 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-2&quot;&gt;代码实现&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Solution
{
public:
    /**
    * @param matrix, a list of lists of integers
    * @param target, an integer
    * @return a boolean, indicate whether matrix contains target
    */
    bool searchMatrix(vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; &amp;amp;matrix, int target)
    {
        int mid = -1;
        int low = 0;
        int high = matrix.size() - 1;

        if(matrix.empty())
            return false;

        while(low &amp;lt;= high)
        {
            mid = (low + high) / 2;
            if(target &amp;lt;= matrix[mid][matrix[mid].size() - 1])
            {
                high = mid - 1;
            }
            else if(target &amp;gt; matrix[mid][matrix[mid].size() - 1])
            {
                low = mid + 1;
            }
        }

        low = 0;
        high = matrix[mid].size() - 1;
        vector&amp;lt;int&amp;gt; tmpVec = matrix[mid];
        while(low &amp;lt;= high)
        {
            mid = (low + high) / 2;
            if(target == tmpVec[mid])
            {
                return true;
            }
            else if(target &amp;lt; tmpVec[mid])
            {
                high = mid - 1;
            }
            else if(target &amp;gt; tmpVec[mid])
            {
                low = mid + 1;
            }
        }
        return false;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Sun, 05 Jul 2015 08:01:18 +0800</pubDate>
        <link>http://www.tangmi.me/blog/search-a-2d-matrix</link>
        <guid isPermaLink="true">http://www.tangmi.me/blog/search-a-2d-matrix</guid>
        
        <category>二分查找</category>
        
        <category>矩阵</category>
        
        
        <category>LintCode</category>
        
      </item>
    
      <item>
        <title>二叉树的最大深度--LintCode</title>
        <description>&lt;p&gt;给定一个二叉树，找出其最大深度。
二叉树的深度为根节点到最远叶子节点的距离。
&lt;!--break--&gt;&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;示例&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;给出一棵如下的二叉树:
  1
 / \ 
2   3
   / \
  4   5
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-1&quot;&gt;算法思路&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;如果根结点为NULL，直接返回为0;
如果根结点不为NULL且左孩子深度大于等于右孩子的深度，那么当前根结点的深度就是左孩子的深度+1；
如果根结点不为NULL且左孩子深度小于右孩子的深度，那么当前根结点的深度就是右孩子的深度+1；
对每个左孩子、右孩子也是采用同样的算法，递归调用直到某一节点为NULL时返回0；
时间复杂度：O(n)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-2&quot;&gt;代码实现&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
* Definition of TreeNode:
* class TreeNode {
* public:
*     int val;
*     TreeNode *left, *right;
*     TreeNode(int val) {
*         this-&amp;gt;val = val;
*         this-&amp;gt;left = this-&amp;gt;right = NULL;
*     }
* }
*/
class Solution
{
public:
    /**
    * @param root: The root of binary tree.
    * @return: An integer
    */
    int maxDepth(TreeNode *root)
    {
        if(root == NULL)
        {
            return 0;
        }
        int leftDepth = maxDepth(root-&amp;gt;left);
        int rightDepth = maxDepth(root-&amp;gt;right);
        return leftDepth &amp;gt;= rightDepth ? leftDepth + 1 : rightDepth + 1;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Sun, 05 Jul 2015 06:15:19 +0800</pubDate>
        <link>http://www.tangmi.me/blog/binary-depth</link>
        <guid isPermaLink="true">http://www.tangmi.me/blog/binary-depth</guid>
        
        <category>二叉树</category>
        
        <category>递归</category>
        
        
        <category>LintCode</category>
        
      </item>
    
      <item>
        <title>Fizz Buzz--LintCode</title>
        <description>&lt;p&gt;给你一个整数n. 从 1 到 n 按照下面的规则打印每个数
&lt;!--break--&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;如果这个数被3整除，打印fizz.
如果这个数被5整除，打印buzz.
如果这个数能同时被3和5整除，打印fizz buzz.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section&quot;&gt;示例&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;比如n=15, 返回一个字符串数组：
[&quot;1&quot;, &quot;2&quot;, &quot;fizz&quot;, &quot;4&quot;, &quot;buzz&quot;, &quot;fizz&quot;, &quot;7&quot;, &quot;8&quot;, &quot;fizz&quot;, &quot;buzz&quot;, &quot;11&quot;, &quot;fizz&quot;, &quot;13&quot;, &quot;14&quot;, &quot;fizz buzz&quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-1&quot;&gt;代码实现&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Solution
{
public:
    /**
    * param n: As description.
    * return: A list of strings.
    */
    vector&amp;lt;string&amp;gt; fizzBuzz(int n)
    {
        vector&amp;lt;string&amp;gt; results;
        for (int i = 1; i &amp;lt;= n; i++)
        {
            if (i % 15 == 0)
            {
                results.push_back(&quot;fizz buzz&quot;);
            }
            else if (i % 5 == 0)
            {
                results.push_back(&quot;buzz&quot;);
            }
            else if (i % 3 == 0)
            {
                results.push_back(&quot;fizz&quot;);
            }
            else
            {
                results.push_back(to_string(i));
            }
        }
        return results;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Sun, 05 Jul 2015 03:33:19 +0800</pubDate>
        <link>http://www.tangmi.me/blog/lintcode</link>
        <guid isPermaLink="true">http://www.tangmi.me/blog/lintcode</guid>
        
        <category>枚举</category>
        
        
        <category>LintCode</category>
        
      </item>
    
      <item>
        <title>读书计划</title>
        <description>&lt;p&gt;下半年读书计划
&lt;!--break--&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;数学基础&lt;/h2&gt;

&lt;h3 id=&quot;section-1&quot;&gt;微积分&lt;/h3&gt;

&lt;h4 id=&quot;httpstudy163complanplanintroductionhtmid1200133targetblank&quot;&gt;2. &lt;a href=&quot;http://study.163.com/plan/planIntroduction.htm?id=1200133&quot; target=&quot;_blank&quot;&gt;公开课–单变量微积分&lt;/a&gt;&lt;/h4&gt;

&lt;h4 id=&quot;httpstudy163complanplanintroductionhtmid1200153targetblank&quot;&gt;3. &lt;a href=&quot;http://study.163.com/plan/planIntroduction.htm?id=1200153&quot; target=&quot;_blank&quot;&gt;公开课–单变量微积分习题课&lt;/a&gt;&lt;/h4&gt;

&lt;h4 id=&quot;httpstudy163complanplanintroductionhtmid1200069targetblank&quot;&gt;4. &lt;a href=&quot;http://study.163.com/plan/planIntroduction.htm?id=1200069&quot; target=&quot;_blank&quot;&gt;多变量微积分&lt;/a&gt;&lt;/h4&gt;

&lt;h3 id=&quot;section-2&quot;&gt;概率论&lt;/h3&gt;

&lt;h4 id=&quot;httpbookdoubancomsubject2201479targetblank&quot;&gt;1. &lt;a href=&quot;http://book.douban.com/subject/2201479/&quot; target=&quot;_blank&quot;&gt;概率论与数理统计&lt;/a&gt;&lt;/h4&gt;

&lt;h3 id=&quot;section-3&quot;&gt;线性代数&lt;/h3&gt;

&lt;h4 id=&quot;httpbookdoubancomsubject2016789targetblank&quot;&gt;1. &lt;a href=&quot;http://book.douban.com/subject/2016789/&quot; target=&quot;_blank&quot;&gt;线性代数&lt;/a&gt;&lt;/h4&gt;

&lt;h3 id=&quot;section-4&quot;&gt;其他&lt;/h3&gt;

&lt;h4 id=&quot;httpbookdoubancomsubject19949020targetblank&quot;&gt;1. &lt;a href=&quot;http://book.douban.com/subject/19949020/&quot; target=&quot;_blank&quot;&gt;程序员的数学&lt;/a&gt;&lt;/h4&gt;

&lt;h4 id=&quot;httpbookdoubancomsubject10750155targetblank&quot;&gt;2. &lt;a href=&quot;http://book.douban.com/subject/10750155/&quot; target=&quot;_blank&quot;&gt;数学之美&lt;/a&gt;&lt;/h4&gt;

&lt;h4 id=&quot;httpbookdoubancomsubject10455982targetblank&quot;&gt;3. &lt;a href=&quot;http://book.douban.com/subject/10455982/&quot; target=&quot;_blank&quot;&gt;什么是数学：对思想和方法的基本研究&lt;/a&gt;&lt;/h4&gt;

&lt;h4 id=&quot;httpbookdoubancomsubject1281343targetblank&quot;&gt;4. &lt;a href=&quot;http://book.douban.com/subject/1281343/&quot; target=&quot;_blank&quot;&gt;微积分和数学分析引论&lt;/a&gt;&lt;/h4&gt;

&lt;h2 id=&quot;section-5&quot;&gt;机器学习&lt;/h2&gt;

&lt;h4 id=&quot;nghttpswwwcourseraorgcoursemltargetblank&quot;&gt;1. &lt;a href=&quot;https://www.coursera.org/course/ml&quot; target=&quot;_blank&quot;&gt;公开课–Ng的机器学习&lt;/a&gt;&lt;/h4&gt;

&lt;h4 id=&quot;httpsbookdoubancomsubject24703171targetblank&quot;&gt;2. &lt;a href=&quot;https://book.douban.com/subject/24703171/&quot; target=&quot;_blank&quot;&gt;机器学习实战&lt;/a&gt;&lt;/h4&gt;

&lt;h4 id=&quot;httpstudy163complanplanintroduction1200146htmtargetblank&quot;&gt;3. &lt;a href=&quot;http://study.163.com/plan/planIntroduction/1200146.htm&quot; target=&quot;_blank&quot;&gt;公开课–斯坦福机器学习&lt;/a&gt;&lt;/h4&gt;

</description>
        <pubDate>Sat, 28 Mar 2015 19:57:19 +0800</pubDate>
        <link>http://www.tangmi.me/blog/book-list</link>
        <guid isPermaLink="true">http://www.tangmi.me/blog/book-list</guid>
        
        <category>读书</category>
        
        <category>数学</category>
        
        <category>机器学习</category>
        
        
        <category>读书</category>
        
      </item>
    
      <item>
        <title>gRPC体验</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://7xi7ny.com1.z0.glb.clouddn.com/grpc.png&quot; alt=&quot;Alt text&quot; title=&quot;gRPC&quot; /&gt;&lt;/p&gt;

&lt;p&gt;大名鼎鼎的grpc出来不久，赶紧下来体验一把，该文主要记录安装过程以及简单的hello程序。
&lt;!--break--&gt;&lt;/p&gt;

&lt;h2 id=&quot;grpc&quot;&gt;grpc安装&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;1. 下载源码&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git clone https://github.com/grpc/grpc.git grpc; cd grpc;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-1&quot;&gt;2. 更新第三方源码&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git submodule update --init
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;font color=&quot;red&quot;&gt;注意：执行这一步更新命令前，需要修改.gitmodules文件，我已经通过goog code “一键export to github“ 功能 把gflags项目源码导入到了github(google code无法通过git访问)，修改后的文件如下：&lt;/font&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[submodule &quot;third_party/zlib&quot;]
	    path = third_party/zlib
    	url = https://github.com/madler/zlib
[submodule &quot;third_party/openssl&quot;]
	    path = third_party/openssl
        url = https://github.com/openssl/openssl.git
	    branch = OpenSSL_1_0_2-stable
[submodule &quot;third_party/protobuf&quot;]
	    path = third_party/protobuf
	    url = https://github.com/google/protobuf.git
	    branch = v3.0.0-alpha-2
[submodule &quot;third_party/gflags&quot;]
	    path = third_party/gflags
	    url = https://github.com/tangmi360/gflags.git
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-2&quot;&gt;3. 编译并安装&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ make
$ sudo make install prefix=/usr/local/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;到此，grpc已经成功安装在系统中。&lt;/p&gt;

&lt;h2 id=&quot;protobuf-300&quot;&gt;protobuf 3.0.0安装&lt;/h2&gt;

&lt;h3 id=&quot;thirdparty&quot;&gt;1. 进入third_party目录&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd third_party/protobuf
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;autogenshconfigure&quot;&gt;2. 通过autogen.sh脚本生成configure&lt;/h3&gt;

&lt;p&gt;protobuf从github拉下的源码默认是没有configure文件，需要通过执行autogen.sh来生成&lt;br /&gt;
不过需要修改下脚本，修改后脚本片断如下（22-25行被注释掉了，26行是新加）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;20 if test ! -e gtest; then
21   echo &quot;Google Test not present.  Fetching gtest-1.7.0 from the web...&quot;
22   #curl -O https://googletest.googlecode.com/files/gtest-1.7.0.zip
23   #unzip -q gtest-1.7.0.zip
24   #rm gtest-1.7.0.zip
25   #mv gtest-1.7.0 gtest
26   git clone https://github.com/tangmi360/googletest.git gtest
27 fi
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-3&quot;&gt;3. 编译并安装&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ./autogen.sh
$ ./configure --prefix=/usr/local
$ make
$ make check
$ sudo make install
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;ldconf&quot;&gt;4. 添加动态库到ldconf配置&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo vim /etc/ld.so.conf.d/grpc.conf
$ 添加一行 &quot;/usr/local/lib&quot;
$ sudo ldconfig
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;hello-c-grpc&quot;&gt;Hello C++ gRPC!&lt;/h2&gt;

&lt;h3 id=&quot;grpc-common&quot;&gt;1. 下载 grpc-common&lt;/h3&gt;

&lt;p&gt;该项目是grpc的使用示例程序以及帮助文档&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git clone https://github.com/grpc/grpc-common.git
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;rpc&quot;&gt;2. 生成rpc接口代码&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd grpc-common/cpp/helloworld/
$ make helloworld.pb.cc
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其实生成接口代码执行的是这条命令:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ protoc -I ../../protos --cpp_out=. --grpc_out=. --plugin=protoc-gen-grpc=`which grpc_cpp_plugin` ../../protos/helloworld.proto
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-4&quot;&gt;3. 代码示例&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;greeter_server.cc&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;memory&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;grpc/grpc.h&amp;gt;
#include &amp;lt;grpc++/server.h&amp;gt;
#include &amp;lt;grpc++/server_builder.h&amp;gt;
#include &amp;lt;grpc++/server_context.h&amp;gt;
#include &amp;lt;grpc++/server_credentials.h&amp;gt;
#include &amp;lt;grpc++/status.h&amp;gt;
#include &quot;helloworld.pb.h&quot;

using grpc::Server;
using grpc::ServerBuilder;
using grpc::ServerContext;
using grpc::Status;
using helloworld::HelloRequest;
using helloworld::HelloReply;
using helloworld::Greeter;

class GreeterServiceImpl final : public Greeter::Service {
    Status SayHello(ServerContext* context, const HelloRequest* request, HelloReply* reply) override {
        std::string prefix(&quot;Hello &quot;);
        reply-&amp;gt;set_message(prefix + request-&amp;gt;name());
        return Status::OK;
    }
};

void RunServer() {
    std::string server_address(&quot;0.0.0.0:50051&quot;);
    GreeterServiceImpl service;
    ServerBuilder builder;
    builder.AddListeningPort(server_address,
    grpc::InsecureServerCredentials());
    builder.RegisterService(&amp;amp;service);
    std::unique_ptr&amp;lt;Server&amp;gt; server(builder.BuildAndStart());
    std::cout &amp;lt;&amp;lt; &quot;Server listening on &quot; &amp;lt;&amp;lt; server_address &amp;lt;&amp;lt; std::endl;
    server-&amp;gt;Wait();
}

int main(int argc, char** argv) {
    grpc_init();
    RunServer();
    grpc_shutdown();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;greeter_client.cc&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;memory&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;grpc/grpc.h&amp;gt;
#include &amp;lt;grpc++/channel_arguments.h&amp;gt;
#include &amp;lt;grpc++/channel_interface.h&amp;gt;
#include &amp;lt;grpc++/client_context.h&amp;gt;
#include &amp;lt;grpc++/create_channel.h&amp;gt;
#include &amp;lt;grpc++/credentials.h&amp;gt;
#include &amp;lt;grpc++/status.h&amp;gt;
#include &quot;helloworld.pb.h&quot;

using grpc::ChannelArguments;
using grpc::ChannelInterface;
using grpc::ClientContext;
using grpc::Status;
using helloworld::HelloRequest;
using helloworld::HelloReply;
using helloworld::Greeter;

class GreeterClient {
  public:
    GreeterClient(std::shared_ptr&amp;lt;ChannelInterface&amp;gt; channel) : stub_(Greeter::NewStub(channel)) {}

    std::string SayHello(const std::string&amp;amp; user) {
        HelloRequest request;
        request.set_name(user);
        HelloReply reply;
        ClientContext context;
        Status status = stub_-&amp;gt;SayHello(&amp;amp;context, request, &amp;amp;reply);
        if (status.IsOk()) {
            return reply.message();
        } else {
            return &quot;Rpc failed&quot;;
        }
    }
    void Shutdown() { stub_.reset(); }
  private:
    std::unique_ptr&amp;lt;Greeter::Stub&amp;gt; stub_;
};

int main(int argc, char** argv) {
    grpc_init();
    GreeterClient greeter(
    grpc::CreateChannel(&quot;localhost:50051&quot;, grpc::InsecureCredentials(),
        ChannelArguments()));
    std::string user(&quot;world&quot;);
    std::string reply = greeter.SayHello(user);
    std::cout &amp;lt;&amp;lt; &quot;Greeter received: &quot; &amp;lt;&amp;lt; reply &amp;lt;&amp;lt; std::endl;
    greeter.Shutdown();
    grpc_shutdown();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;hello&quot;&gt;4. 编译hello程序&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ make
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-5&quot;&gt;5. 运行&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ./greeter_server
$ ./greeter_client
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出结果:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Hello world
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-6&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;本文记录了一下安装编译过程，并简单体验了一下c++版本的hello程序，接下来陆续会对grpc的源码进行分析。&lt;/p&gt;
</description>
        <pubDate>Wed, 25 Mar 2015 00:12:11 +0800</pubDate>
        <link>http://www.tangmi.me/blog/grpc-experience</link>
        <guid isPermaLink="true">http://www.tangmi.me/blog/grpc-experience</guid>
        
        <category>gRPC</category>
        
        <category>服务器</category>
        
        
        <category>服务器</category>
        
      </item>
    
      <item>
        <title>猫咪文生</title>
        <description>&lt;p&gt;2013年8月的某一天，公司外面稀稀拉拉下着小雨，它趴在小树上不敢下来被好心同事发现后，被我收养回家，小家伙当时也就一个月大，取名文生，现在1岁半了。
&lt;!--break--&gt;&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;（持续更新…）&lt;/h4&gt;

&lt;p&gt;看风景 &lt;br /&gt;
&lt;img src=&quot;http://7xi7ny.com1.z0.glb.clouddn.com/%E5%96%B5%E5%96%B5.png?imageView2/1/w/600/h/600&quot; alt=&quot;Alt text&quot; title=&quot;看风景&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我要吃饭&lt;br /&gt;
&lt;img src=&quot;http://7xi7ny.com1.z0.glb.clouddn.com/wensheng1800759295.jpg?imageView2/1/w/600/h/600&quot; alt=&quot;Alt text&quot; title=&quot;我要吃饭&quot; /&gt;&lt;/p&gt;

&lt;p&gt;困了睡一觉&lt;br /&gt;
&lt;img src=&quot;http://7xi7ny.com1.z0.glb.clouddn.com/wensheng1811490104.jpg?imageView2/1/w/600/h/600&quot; alt=&quot;Alt text&quot; title=&quot;困了睡一觉&quot; /&gt;
&lt;img src=&quot;http://7xi7ny.com1.z0.glb.clouddn.com/wensheng433671667.jpg?imageView2/1/w/600/h/600&quot; alt=&quot;Alt text&quot; title=&quot;困了睡一觉&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看什么呢？&lt;br /&gt;
&lt;img src=&quot;http://7xi7ny.com1.z0.glb.clouddn.com/wensheng1955730224.jpg?imageView2/1/w/600/h/600&quot; alt=&quot;Alt text&quot; title=&quot;看什么呢？ &quot; /&gt;
&lt;img src=&quot;http://7xi7ny.com1.z0.glb.clouddn.com/wensheng2072715493.jpg?imageView2/1/w/600/h/600&quot; alt=&quot;Alt text&quot; title=&quot;看什么呢？ &quot; /&gt;
&lt;img src=&quot;http://7xi7ny.com1.z0.glb.clouddn.com/wensheng254827326.jpg?imageView2/1/w/600/h/600&quot; alt=&quot;Alt text&quot; title=&quot;看什么呢？ &quot; /&gt;
&lt;img src=&quot;http://7xi7ny.com1.z0.glb.clouddn.com/wensheng37924335.jpg?imageView2/1/w/600/h/600&quot; alt=&quot;Alt text&quot; title=&quot;看什么呢？ &quot; /&gt;
&lt;img src=&quot;http://7xi7ny.com1.z0.glb.clouddn.com/wensheng827239326.jpg?imageView2/1/w/600/h/600&quot; alt=&quot;Alt text&quot; title=&quot;看什么呢？ &quot; /&gt;
&lt;img src=&quot;http://7xi7ny.com1.z0.glb.clouddn.com/wensheng1699985725.jpg?imageView2/1/w/600/h/600&quot; alt=&quot;Alt text&quot; title=&quot;看什么呢？ &quot; /&gt;&lt;/p&gt;

&lt;p&gt;我就是这么拽&lt;br /&gt;
&lt;img src=&quot;http://7xi7ny.com1.z0.glb.clouddn.com/wensheng2097720226.jpg?imageView2/1/w/600/h/600&quot; alt=&quot;Alt text&quot; title=&quot;我就是这么拽&quot; /&gt;
&lt;img src=&quot;http://7xi7ny.com1.z0.glb.clouddn.com/wensheng702749384.jpg?imageView2/1/w/600/h/600&quot; alt=&quot;Alt text&quot; title=&quot;我就是这么拽&quot; /&gt;&lt;/p&gt;

&lt;p&gt;谢谢你的陪伴。&lt;/p&gt;
</description>
        <pubDate>Mon, 23 Mar 2015 08:11:10 +0800</pubDate>
        <link>http://www.tangmi.me/blog/wensheng</link>
        <guid isPermaLink="true">http://www.tangmi.me/blog/wensheng</guid>
        
        <category>文生</category>
        
        
        <category>心情</category>
        
      </item>
    
  </channel>
</rss>
