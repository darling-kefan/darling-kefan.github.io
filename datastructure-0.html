<!DOCTYPE HTML>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta name="Keywords" content="blog"/>
    <meta name="Description" content="blog"/>
    <title>tangmi的笔记本</title>
    <!--<link rel="shortcut icon" href="/static/favicon.png"/>-->
    <link rel="stylesheet" type="text/css" href="/main.css" />
</head>
<body>
<div class="main">
    <div class="header">
    	<ul id="pages">
            <li><a href="/">home</a></li>
            <li><a href="/#/tags">tags</a></li>
            <li><a href="/#/archive">archive</a></li>
            <li>
                <a href="http://www.tangmi.me/src/index.html" target="_blank">editor</a>
            </li>
    	</ul>
    </div>
	<div class="wrap-header">
	<h1>
    <a href="/" id="title"></a>
	</h1>
	</div>
<div id="md" style="display: none;">
<!-- markdown -->
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>
### **本章概要**
在这一章，作者阐述了本书的目的和目标，对于面临大量输入的算法，花费时间是一个判别其好坏的重要标准，并简要复习数学基础以及程序设计的一些概念。


### **本章重点**
1. 数学复习 (指数、对数、级数、模运算、数学归纳法、反证法)

#### **指数**

$X^AX^B = X^{A+B}$
$\frac{X^A}{X^B} = X^{A-B}$
$(X^A)^B = X^{AB}$
${X^N} + {X^N} = 2X^N \not= X^{2N}$
$2^N + 2^N = 2^{N+1}$

#### **对数**

在计算机科学中，除非有特别的声明，所有对数都是以2为底的。

定义：$X^A = B$，当且仅当 $\log{X}B = A$，由该定义可以得到几个方便的等式。

$\log{A}B = \frac{\log{C}B}{\log_{C}A}$

证明：令 $X = \log{C}B$，$Y = \log{C}A$，$Z = \log{A}B$。此时由对数的定义得：$C^X = B$，$C^Y = A$，$A^Z = B$。联合这三个等式则产生 $(C^Y)^Z = B = C^X$。因此，X = YZ，这意味着 Z = X / Y，定理得证。

$\log AB = \log A + \log B$

证明：令 $X = \log A$，$Y = \log B$，$Z = \log AB$，假设默认的底为2，$2^X = A$，$2^Y = B$，$2^Z = AB$，联合最后这三个等式则有 $2^X2^Y = 2^Z = AB$，因此 X + Y = Z，定理得证。

$\log A/B = \log A - \log B$

$\log (A^B) = B \log A$

$\log X < X$ (对所有的X > 0 成立)

$\log 1 = 0$，$\log 2 = 1$，$\log 1024 = 10$，$\log 1048576 = 20$


2.递归法则

- 基准情形：必须总是要有某些基准的情形，它们不用递归就能求解
- 不断推进：对于需要递归求解的情形，每一次递归调用都必须要使求解状况朝基准情形的方向推进
- 设计法则：假设所有的递归调用都能运行
- 合成效益法则：在求解一个问题的同一实例时，切勿在不同的递归调用中做重复性的工作（**重要**）


### **课后习题**

1. 编写一个程序解决选择问题。令k = N/2。画出表格显示你的程序对于 N 为不同值的运行时间。
    ```C
    /*
     * =====================================================================================
     *
     *    Filename:  Select.c
     *    Description:  选择第K大的数
     *
     *    Version:  1.0
     *    Created:  2014年08月30日 21时22分29秒
     *    Revision:  none
     *    Compiler:  gcc
     *    Author:  tangmi
     *
     * =====================================================================================
     */
     #include <stdio.h>
     #include <string.h>
     #include <time.h>

    int partition(int *arr, int begin, int end)
    {
        int x = arr[end];
        int i = begin - 1;
        int idx;
        for (idx = begin; idx < end; ++idx)
        {
            if (arr[idx] > x)
            {
                ++i;
                swap(arr, i, idx);
            }
        }
        swap(arr, i + 1, end);
        return i + 1;
    }

    inline swap(int *arr, int lhs, int rhs)
    {
        int temp = arr[lhs];
        arr[lhs] = arr[rhs];
        arr[rhs] = temp;
    }

    int selectK(int *arr, int begin, int end, int k)
    {
        if (begin == end)
          return arr[begin];
        int q = partition(arr, begin, end);
        int m = q - begin + 1;
        if (m == k)
            return arr[q];
        else if (m < k)
            return selectK(arr, q + 1, end, k - m);
        else
            return selectK(arr, begin, q - 1, k);
    }

    int main(void)
    {
        int arr[] = {1, 2, 4, 8, 3, 5};
        struct  timeval  start;
        struct  timeval  end;
        unsigned long timer;
        int i, kV;
        for(i = 0; i < 6; ++i)
        {
            gettimeofday(&start, NULL);
            kV = selectK(arr, 0, i, (i + 1) / 2);
            gettimeofday(&end, NULL);
            timer = 1000000 * (end.tv_sec - start.tv_sec) + end.tv_usec - start.tv_usec;
            printf("kV=%d, spend time=%ld us\n", kV, timer);
        }
        return 0;
    }
    ```

2. 编写一个程序求解字谜游戏问题

3. 只使用处理I/O的printDigit函数，编写一个过程以输出任意实数（可以是负的）。

4. C提供形如 `#include filename` 的语句，它读入文件filename并将其插入到include语句处。include语句可以嵌套；换句话说，文件filename本身还可以包含include语句，但是显然一个文件在任何链接中都不能包含它自己。编写一个程序，使它读入被include语句修饰的一个文件并且输出这个文件。

5. 证明下列公式：
    a. $log x < x$ 对所有的 $x > 0$ 成立。
    > 通过归纳法证明：
    当 $x = 1$ 时，$\log x = 0$，$\log x < x$;
    当 $0 < x < 1$ 时, $\log x < 0$, x > 0，$\log x < x$; 
    当 $x > 1$ 时，令 $\log x = y$，则 $x = 2^y$;
    比较 $y$ 和 $2^y$ 的大小：
    假设 $y = n$ 时，$2^n > n$，$n$为任意大于0小于1的实数,
    则 $y = n + 1$ 时，$2^{n + 1} = 2^n * 2 > 2 > n + 1$;
    即，$1 < n + 1 < 2$ 时，不等式满足;
    假设 $y = n$ 时，$2^n > n$，n为任意大于1的实数,
    则 $y = n + 1$ 时，$2^{n + 1} = 2^n * 2 > 2^n > n + 1$; 
    综上，即证明了 $log x < x$.

    b. $\log(A^B) = B\log A$
    > 令 $X=\log A, A = 2^X, A^B = 2^{XB}$，因此 $\log (A^B) = XB$，由于$X=\log A$, 定理得证.

6. 求下列各和：
    a. $\sum_{i=0}^\infty \frac{1}{4^i}$
    > 令S表示和，则有：
    S = $\frac{1}{4^0}$ + $\frac{1}{4^1}$ + $\frac{1}{4^2}$ + $\frac{1}{4^3}$ + ... ...
    于是
    $\frac{S}{4}$ = $\frac{1}{4^1}$ + $\frac{1}{4^2}$ + $\frac{1}{4^3}$ + ... ...
    两式相减：S - $\frac{S}{4}$ = $\frac{1}{4^0}$  = 1，因此 S = $\frac{4}{3}$

    b. $\sum_{i=0}^\infty \frac{i}{4^i}$
    > 令S表示和，则有：
    S = $\frac{1}{4}$ + $\frac{2}{4^2}$ + $\frac{3}{4^3}$ + $\frac{4}{4^4}$ + ... ...
    于是
    4S = 1 + $\frac{2}{4^1}$ + $\frac{3}{4^2}$ + $\frac{4}{4^3}$ + $\frac{5}{4^4}$ + ... ...
    两式相减：4S - S = 3S = 1 + $\frac{1}{4}$ + $\frac{1}{4^2}$ + $\frac{1}{4^3}$ + $\frac{1}{4^4}$ + ... ...
    因为该和与上题中的S的和相等，则 3S = $\frac{4}{3}$，因此 S = $\frac{4}{9}$

    c. $\sum_{i=0}^\infty \frac{i^2}{4^i}$
    > 令S表示和，则有：
    S = $\frac{1}{4}$ + $\frac{2^2}{4^2}$ + $\frac{3^2}{4^3}$ + ... ...
    于是
    4S = 1 + $\frac{4}{4}$ + $\frac{9}{4^2}$ + $\frac{16}{4^3}$ + ... ...
    两式相减：3S = 1 + $\frac{3}{4}$ + $\frac{5}{4^2}$ + $\frac{7}{4^3}$ + ... ...
    重新整理得到：$2\sum_{i=0}^\infty \frac{i}{4^i} + \sum_{i=0}^\infty \frac{1}{4^i}$，因此 3S = 2($\frac{4}{9}$) + $\frac{4}{3}$，因此 S = $\frac{20}{27}$

    d. $\sum_{i=0}^\infty \frac{i^N}{4^i}$
    > xxx

7. 估计 $\sum_{i=N/2}^N \frac{1}{i}$

8. ${2^{100}} (mod 5)$ 是多少？
> 1

9. 令 $F_i$ 是在1.2节中定义的斐波那契数。证明下列公式：
    a. $\sum_{i=1}^{N-2} F_i = F_N - 2$

    b. $F_N < a^N$，其中 $a = (1 + \sqrt 5) / 2$

10. 证明下列公式：
    a. $\sum_{i=1}^N (2i - 1) = N^2$

    b. $\sum_{i=1}^N i^3 = (\sum_{i=1}^N i)^2$

### **本章总结**
xxx
<!-- markdown end -->
</div>
<div class="entry" id="main">
<!-- content -->
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

<h3 id=""><strong>本章概要</strong></h3>

<p>在这一章，作者阐述了本书的目的和目标，对于面临大量输入的算法，花费时间是一个判别其好坏的重要标准，并简要复习数学基础以及程序设计的一些概念。</p>

<h3 id=""><strong>本章重点</strong></h3>

<ol>
<li>数学复习 (指数、对数、级数、模运算、数学归纳法、反证法)</li>
</ol>

<h4 id=""><strong>指数</strong></h4>

<p>$X^AX^B = X^{A+B}$
$\frac{X^A}{X^B} = X^{A-B}$
$(X^A)^B = X^{AB}$
${X^N} + {X^N} = 2X^N \not= X^{2N}$
$2^N + 2^N = 2^{N+1}$</p>

<h4 id=""><strong>对数</strong></h4>

<p>在计算机科学中，除非有特别的声明，所有对数都是以2为底的。</p>

<p>定义：$X^A = B$，当且仅当 $\log{X}B = A$，由该定义可以得到几个方便的等式。</p>

<p>$\log{A}B = \frac{\log{C}B}{\log_{C}A}$</p>

<p>证明：令 $X = \log{C}B$，$Y = \log{C}A$，$Z = \log{A}B$。此时由对数的定义得：$C^X = B$，$C^Y = A$，$A^Z = B$。联合这三个等式则产生 $(C^Y)^Z = B = C^X$。因此，X = YZ，这意味着 Z = X / Y，定理得证。</p>

<p>$\log AB = \log A + \log B$</p>

<p>证明：令 $X = \log A$，$Y = \log B$，$Z = \log AB$，假设默认的底为2，$2^X = A$，$2^Y = B$，$2^Z = AB$，联合最后这三个等式则有 $2^X2^Y = 2^Z = AB$，因此 X + Y = Z，定理得证。</p>

<p>$\log A/B = \log A - \log B$</p>

<p>$\log (A^B) = B \log A$</p>

<p>$\log X &lt; X$ (对所有的X &gt; 0 成立)</p>

<p>$\log 1 = 0$，$\log 2 = 1$，$\log 1024 = 10$，$\log 1048576 = 20$</p>

<p>2.递归法则</p>

<ul>
<li>基准情形：必须总是要有某些基准的情形，它们不用递归就能求解</li>
<li>不断推进：对于需要递归求解的情形，每一次递归调用都必须要使求解状况朝基准情形的方向推进</li>
<li>设计法则：假设所有的递归调用都能运行</li>
<li>合成效益法则：在求解一个问题的同一实例时，切勿在不同的递归调用中做重复性的工作（<strong>重要</strong>）</li>
</ul>

<h3 id=""><strong>课后习题</strong></h3>

<ol>
<li><p>编写一个程序解决选择问题。令k = N/2。画出表格显示你的程序对于 N 为不同值的运行时间。
```C
/*</p>

<ul><li>=====================================================================================
*</li>
<li>Filename:  Select.c</li>
<li>Description:  选择第K大的数
*</li>
<li>Version:  1.0</li>
<li>Created:  2014年08月30日 21时22分29秒</li>
<li>Revision:  none</li>
<li>Compiler:  gcc</li>
<li>Author:  tangmi
*</li>
<li>=====================================================================================
*/
#include <stdio.h>
#include <string.h>
#include <time.h></time.h></string.h></stdio.h></li></ul>

<p>int partition(int *arr, int begin, int end)
{
    int x = arr[end];
    int i = begin - 1;
    int idx;
    for (idx = begin; idx &lt; end; ++idx)
    {
        if (arr[idx] &gt; x)
        {
            ++i;
            swap(arr, i, idx);
        }
    }
    swap(arr, i + 1, end);
    return i + 1;
}</p>

<p>inline swap(int *arr, int lhs, int rhs)
{
    int temp = arr[lhs];
    arr[lhs] = arr[rhs];
    arr[rhs] = temp;
}</p>

<p>int selectK(int *arr, int begin, int end, int k)
{
    if (begin == end)
      return arr[begin];
    int q = partition(arr, begin, end);
    int m = q - begin + 1;
    if (m == k)
        return arr[q];
    else if (m &lt; k)
        return selectK(arr, q + 1, end, k - m);
    else
        return selectK(arr, begin, q - 1, k);
}</p>

<p>int main(void)
{
    int arr[] = {1, 2, 4, 8, 3, 5};
    struct  timeval  start;
    struct  timeval  end;
    unsigned long timer;
    int i, kV;
    for(i = 0; i &lt; 6; ++i)
    {
        gettimeofday(&amp;start, NULL);
        kV = selectK(arr, 0, i, (i + 1) / 2);
        gettimeofday(&amp;end, NULL);
        timer = 1000000 * (end.tv<em>sec - start.tv</em>sec) + end.tv<em>usec - start.tv</em>usec;
        printf("kV=%d, spend time=%ld us\n", kV, timer);
    }
    return 0;
}
```</p></li>
<li><p>编写一个程序求解字谜游戏问题</p></li>
<li><p>只使用处理I/O的printDigit函数，编写一个过程以输出任意实数（可以是负的）。</p></li>
<li><p>C提供形如 <code>#include filename</code> 的语句，它读入文件filename并将其插入到include语句处。include语句可以嵌套；换句话说，文件filename本身还可以包含include语句，但是显然一个文件在任何链接中都不能包含它自己。编写一个程序，使它读入被include语句修饰的一个文件并且输出这个文件。</p></li>
<li><p>证明下列公式：
a. $log x &lt; x$ 对所有的 $x &gt; 0$ 成立。</p>

<blockquote>
  <p>通过归纳法证明：
  当 $x = 1$ 时，$\log x = 0$，$\log x &lt; x$;
  当 $0 &lt; x &lt; 1$ 时, $\log x &lt; 0$, x &gt; 0，$\log x &lt; x$; 
  当 $x &gt; 1$ 时，令 $\log x = y$，则 $x = 2^y$;
  比较 $y$ 和 $2^y$ 的大小：
  假设 $y = n$ 时，$2^n &gt; n$，$n$为任意大于0小于1的实数,
  则 $y = n + 1$ 时，$2^{n + 1} = 2^n * 2 &gt; 2 &gt; n + 1$;
  即，$1 &lt; n + 1 &lt; 2$ 时，不等式满足;
  假设 $y = n$ 时，$2^n &gt; n$，n为任意大于1的实数,
  则 $y = n + 1$ 时，$2^{n + 1} = 2^n * 2 &gt; 2^n &gt; n + 1$; 
  综上，即证明了 $log x &lt; x$.</p>
</blockquote>

<p>b. $\log(A^B) = B\log A$</p>

<blockquote>
  <p>令 $X=\log A, A = 2^X, A^B = 2^{XB}$，因此 $\log (A^B) = XB$，由于$X=\log A$, 定理得证.</p>
</blockquote></li>
<li><p>求下列各和：
a. $\sum_{i=0}^\infty \frac{1}{4^i}$</p>

<blockquote>
  <p>令S表示和，则有：
  S = $\frac{1}{4^0}$ + $\frac{1}{4^1}$ + $\frac{1}{4^2}$ + $\frac{1}{4^3}$ + ... ...
  于是
  $\frac{S}{4}$ = $\frac{1}{4^1}$ + $\frac{1}{4^2}$ + $\frac{1}{4^3}$ + ... ...
  两式相减：S - $\frac{S}{4}$ = $\frac{1}{4^0}$  = 1，因此 S = $\frac{4}{3}$</p>
</blockquote>

<p>b. $\sum_{i=0}^\infty \frac{i}{4^i}$</p>

<blockquote>
  <p>令S表示和，则有：
  S = $\frac{1}{4}$ + $\frac{2}{4^2}$ + $\frac{3}{4^3}$ + $\frac{4}{4^4}$ + ... ...
  于是
  4S = 1 + $\frac{2}{4^1}$ + $\frac{3}{4^2}$ + $\frac{4}{4^3}$ + $\frac{5}{4^4}$ + ... ...
  两式相减：4S - S = 3S = 1 + $\frac{1}{4}$ + $\frac{1}{4^2}$ + $\frac{1}{4^3}$ + $\frac{1}{4^4}$ + ... ...
  因为该和与上题中的S的和相等，则 3S = $\frac{4}{3}$，因此 S = $\frac{4}{9}$</p>
</blockquote>

<p>c. $\sum_{i=0}^\infty \frac{i^2}{4^i}$</p>

<blockquote>
  <p>令S表示和，则有：
  S = $\frac{1}{4}$ + $\frac{2^2}{4^2}$ + $\frac{3^2}{4^3}$ + ... ...
  于是
  4S = 1 + $\frac{4}{4}$ + $\frac{9}{4^2}$ + $\frac{16}{4^3}$ + ... ...
  两式相减：3S = 1 + $\frac{3}{4}$ + $\frac{5}{4^2}$ + $\frac{7}{4^3}$ + ... ...
  重新整理得到：$2\sum<em>{i=0}^\infty \frac{i}{4^i} + \sum</em>{i=0}^\infty \frac{1}{4^i}$，因此 3S = 2($\frac{4}{9}$) + $\frac{4}{3}$，因此 S = $\frac{20}{27}$</p>
</blockquote>

<p>d. $\sum_{i=0}^\infty \frac{i^N}{4^i}$</p>

<blockquote>
  <p>xxx</p>
</blockquote></li>
<li><p>估计 $\sum_{i=N/2}^N \frac{1}{i}$</p></li>
<li><p>${2^{100}} (mod 5)$ 是多少？</p>

<blockquote>
  <p>1</p>
</blockquote></li>
<li><p>令 $F<em>i$ 是在1.2节中定义的斐波那契数。证明下列公式：
a. $\sum</em>{i=1}^{N-2} F<em>i = F</em>N - 2$</p>

<p>b. $F_N &lt; a^N$，其中 $a = (1 + \sqrt 5) / 2$</p></li>
<li><p>证明下列公式：
a. $\sum_{i=1}^N (2i - 1) = N^2$</p>

<p>b. $\sum<em>{i=1}^N i^3 = (\sum</em>{i=1}^N i)^2$</p></li>
</ol>

<h3 id=""><strong>本章总结</strong></h3>

<p>xxx</p>
<!-- content end -->
</div>
<br>
<br>
    <div id="disqus_thread"></div>
	<div class="footer">
		<p>© Copyright 2014 by tangmi, Designed by isnowfy</p>
	</div>
</div>
<script src="main.js"></script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ["\\(", "\\)"]], processEscapes: true}});
</script>
<script id="content" type="text/mustache">
    <h1>{{title}}</h1>
    <div class="tag">
    {{date}}
    {{#tags}}
    <a href="/#/tag/{{name}}">#{{name}}</a>
    {{/tags}}
    </div>
</script>
<script id="pagesTemplate" type="text/mustache">
    {{#pages}}
    <li>
        <a href="{{path}}">{{title}}</a>
    </li>
    {{/pages}}
</script>
<script>
$(document).ready(function() {
    $.ajax({
        url: "main.json",
        type: "GET",
        dataType: "json",
        success: function(data) {
            $("#title").html(data.name);
            var pagesTemplate = Hogan.compile($("#pagesTemplate").html());
            var pagesHtml = pagesTemplate.render({"pages": data.pages});
            $("#pages").append(pagesHtml);
            //path
            var path = "datastructure-0.html";
            //path end
            var now = 0;
            for (var i = 0; i < data.posts.length; ++i)
                if (path == data.posts[i].path)
                    now = i;
            var post = data.posts[now];
            var tmp = post.tags.split(" ");
            var tags = [];
            for (var i = 0; i < tmp.length; ++i)
                if (tmp[i].length > 0)
                    tags.push({"name": tmp[i]});
            var contentTemplate = Hogan.compile($("#content").html());
            var contentHtml = contentTemplate.render({"title": post.title, "tags": tags, "date": post.date});
            $("#main").prepend(contentHtml);
            if (data.disqus_shortname.length > 0) {
                var disqus_shortname = data.disqus_shortname;
                (function() {
                    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
            }
        }
    });
});
</script>
</body>
</html>
